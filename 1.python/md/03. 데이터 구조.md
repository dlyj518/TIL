# 2. 데이터 구조

## 목차

1. 순서가 있는 데이터 구조
   
   1. String
   
   2. List
   
   3. Tuple

2. 순서가 없는 데이터 구조
   
   1. Set
   
   2. Dictionary

3. 얕은 복사와 깊은 복사
   
   1. 모듈과 패키지
   
   2. 파이선 표준 라이브러리
   
   3. 유용한 패키지/모듈
   
   4. 가상환경
   
   5. 사용자 모듈과 패키지

## 0. 서론

### 1) 데이터 구조 활용

- method 활용
  
  - 클래스 내부에 정의한 함수

- Data.Method()형태로 활용
  
  - ex) List.append(10)

## 1. 순서가 있는 데이터 구조

### 1) 문자열 (String)

- 문자들의 나열 / str 타입

- ''나 "" 통해 표기

- 문자열 메서드
  
  | 문법            | 설명                                 |
  | ------------- | ---------------------------------- |
  | s.find(x)     | x의 첫 번째 위치 반환, 없으면 -1              |
  | s.index(x)    | x의 첫 번째 위치를 반환, 없으면 오류             |
  | s.isalpha()   | 알파벳 문자 여부(유니코드상 letter(한국어 등)도 포함) |
  | s.isupper()   | 대문자 여부                             |
  | s.islower()   | 소문자 여부                             |
  | s.istitle()   | 타이틀 형식 여부(단어마다 첫 글자만 대문자)          |
  | isdemical()   | 문자열 검증 메서드(숫자)                     |
  | s.isdigit()   | 문자열 검증 메서드(수)                      |
  | s.isnumeric() | 문자열 검증 메서드(수로도 가능?)                |

![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2022-07-29-13-45-18-2022-07-25-14-37-12-image.png)

- 문자열 변경 메서드
  
  | 문법                               | 설명                  |
  | -------------------------------- | ------------------- |
  | s.replace(old, new[, count])     | 글자 변경               |
  | s.strip([chars]) / lstrip,rstrip | 공백 혹은 특정 문자 제거      |
  | s.split(sep=None, maxsplit = -1) | 공백 혹은 특정 문자 기준으로 분리 |
  | 'separator'.join([iterable])     | 구분자로 iterable 합침    |
  | s.capitalize()                   | 첫 글자를 대문자로 변경       |
  | s.title()                        | 타이틀 형식으로 변경         |
  | s.upper()                        | 대문자로만 변경            |
  | s.lower()                        | 소문자로만 변경            |
  | s.swapcase()                     | 대소문자 변경             |

- 문자열은 immutable이므로 기존 문자열 변경이 아닌 새로운 문자열을 만드는 것

- split : sep이 None,빈 칸일 경우 연속 공백 문자를 단일 공백으로 간주
  
  - maxsplit -1인 경우 제한 없음

- join : 반복가능 컨테이너에 'seperator'를 넣음
  
  ```python
  print('!'.join('ssafy')) # s!s!a!f!y
  pring(' '.join([3, 5]))  # '3 5'
  ```

### 2) 리스트(List)

- 리스트 메서드
  
  | 문법               | 설명                                  |
  | ---------------- | ----------------------------------- |
  | L.append(x)      | 리스트 마지막에 x 추가                       |
  | L.insert(i, x)   | 리스트 인덱스 i에 x 삽입, 길이보다 크면 끝에 삽입      |
  | L.remove(x)      | 리스트 가장 왼측 x 제거, 존재하지 않으면 ValueError |
  | L.pop()          | 리스트 가장 우측 항목 반환 후 제거                |
  | L.pop(i)         | 리스트 인덱스 i 항목 반환 후 제거                |
  | L.extend(m)      | 순회형 m의 모든 항목들의 리스트 끝에 추가 (+=와 같음)   |
  | L.index(x, s, e) | 리스트 가장 좌측 항목 x의 인덱스 반환              |
  | L.reverse()      | 리스트 거꾸로 정렬                          |
  | L.sort()         | 리스트 정렬 (매개변수 이용가능)                  |
  | L.count(x)       | 리스트에서 x가 몇 개 존재하는지 카운트              |
  | L.clear()        | 리스트 내부 내용 제거                        |

- .extend 예시
  
  ```python
  cafe = ['a', 'b']
  cafe.extned(['abc']) # ['a', 'b', 'abc']
  cafe.extend('abc') # ['a', 'b', 'a', 'b', 'c']
  ```

- L.sort() : 원본을 정렬 / sorted(L) : 원본은 그대로

- L.reverse() : 원본을 뒤집음

### 3) 튜플(Tuple)

- 튜플은 immutable이기 때문에 값에 영향을 미치지 않는 메서드만 가능

- 리스트와 거의 동일

## 2. 순서가 없는 데이터 구조

### 1) 셋 (Set)

- 셋 메서드
  
  | 문법              | 설명                           |
  | --------------- | ---------------------------- |
  | s.copy()        | 셋의 얕은 복사본 반환                 |
  | s.add(x)        | x가 없다면 추가                    |
  | s.update(*x)    | 여러 값x를 을 추가                  |
  | s.pop()         | 랜덤항목 반환 후 제거, 비어있으면 KeyError |
  | s.remove(x)     | x를 s에서 삭제, 존재하지 않으면 KeyError |
  | s.discard(x)    | x를 s에서 삭제                    |
  | s.update(t)     | 셋 t의 항목을 s에 추가               |
  | s.clear()       | 모든 항목 제거                     |
  | s.isdisjoint(t) | 교집합 없으면 True                 |
  | s.issubset(t)   | s$\subset$t이면 True           |
  | s.issuperset(t) | s$\supset$t이면 True           |

### 2) 딕셔너리 (Dictionary)

- 딕셔너리 메서드
  
  | 문법                | 설명                           |
  | ----------------- | ---------------------------- |
  | d.clear()         | 모든 항목 제거                     |
  | d.copy()          | 얕은 복사본 반환                    |
  | d.keys()          | d의 키를 담은 뷰 반환                |
  | d.values()        | d의 값 담은 뷰 반환                 |
  | d.get(k)          | 키 k의 값 반환, 없을 경우 None        |
  | d.get(k, v)       | 키 k의 값 반환, 없을 경우 v           |
  | d.pop(k)          | 키 k의 값 반환 후 삭제, 없으면 KeyError |
  | d.pop(k,v)        | 키 k의 값 반환 후 삭제, 없으면 v        |
  | d.update([other]) | d의 값 매핑해 업데이트                |
  | s.issubset(t)     | s$\subset$t이면 True           |
  | s.issuperset(t)   | s$\supset$t이면 True           |

### 3) 얕은 복사와 깊은 복사

- 복사의 방법
  
  - 할당 (Assignment)
    
    - 대입 연산자 = 사용
    
    - 객체에 대한 객체 참조 복사
    
    - 해당 주소 일부 값 변경 시 참조하는 모든 변수에 영향
  
  - 얕은 복사 (Shallow copy)
    
    - 같은 원소 가진 리스티지만 연산된 결과를 복사(다른 주소)
    
    - 복사하는 리스트의 원소가 주소 참조 시 주의
  
  - 깊은 복사 (Deep copy)
  
  ```python
  import copy
  a = [1, 2, [3, 4]]
  a_a = a
  a_s = a[:]
  a_d = copy.deepcopy(a)
  print(a, a_a, a_s, a_d)
  # [1, 2, [3, 4]] [1, 2, [3, 4]] [1, 2, [3, 4]] [1, 2, [3, 4]]
  a_a[0] = 5
  print(a, a_a, a_s, a_d)
  # [5, 2, [3, 4]] [5, 2, [3, 4]] [1, 2, [3, 4]] [1, 2, [3, 4]]
  a_s[0] = 3
  print(a, a_a, a_s, a_d)
  # [5, 2, [3, 4]] [5, 2, [3, 4]] [3, 2, [3, 4]] [1, 2, [3, 4]]
  a_s[2][0] = 5
  print(a, a_a, a_s, a_d)
  # [5, 2, [5, 4]] [5, 2, [5, 4]] [3, 2, [5, 4]] [1, 2, [3, 4]]
  ```
