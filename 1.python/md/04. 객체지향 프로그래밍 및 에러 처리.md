# 4. 객체지향 프로그래밍(OOP)

## 목차

1. 객체지향 프로그래밍이란?

2. OOP 기초
   
   1. 객체 / 인스턴스 / 클래스
   
   2. 클래스
   
   3. 메서드

3. 객체지향의 핵심 개념
   
   1. 추상화
   
   2. 상속
   
   3. 다형성
   
   4. 캡슐화

## 1. 객체지향 프로그래밍이란?

### 1) 객체지향 프로그래밍

- 프로그램을 여러 개의 독립된 개체들과 객체 간의 상호작용으로 파악하는 프로그래밍 방법

- 예시 : 콘서트 / 가수 객체, 감독 객체, 관객 개체

- cf. 절차지향 프로그래밍    

- 데이터와 기능(메서드) 분리, 추상화된 구조

- 필요한 이유
  
  - 현실 세계를 프로그램 세계에 반영
    
    ```python
    class Person:
        def __init__(self, name, gender):
            self.name = name
            self.gender = gender
        def greeting(self):
            print(f'안녕하세요, {self.name}입니다.')
    jimin = Person('지민', '남')
    jimin.greeting()
    
    jieun = Person('아이유', '여')
    jieun.greeting()
    ```

- 장단점
  
  - 클래스 단위로 모듈화시켜 개발 가능하므로 다인원 참여 대규모 프로젝트에 적합
  
  - 필요한 부분만 수정하기 쉽기 때문에 유지보수 쉬움
  
  - 설계 시 많은 노력/시간 필요
  
  - 실행속도가 상대적으로 느림

## 2. OOP 기초

### 1) 객체 / 인스턴스 /클래스

- 객체 : 속성(정보)과 행동(함수/매서드 등)으로 이루어진 모든 것

- 클래스 : 설계도 느낌(가수 형식 등)

- 인스턴스 : 클래스로 만든 객체
  
  - 가수 클래스의 이찬혁
    
    - 이찬혁은 객체(O)
    
    - 이찬혁은 인스턴스(X)
    
    - 이찬혁은 가수의 인스턴스(O)

- ex) [3, 2, 1].sort()
  
  - 리스트.정렬() == 객체.행동()

- [1, 2, 3], [1], [] : 모두 리스트 타입(클래스)의 객체, 각각은 리스트 타입의 인스턴스

- 객체의 특징
  
  - 타입(type) : 연산자(operator)와 조작(method)가 가능한가
  
  - 속성(attribute) : 어떤 상태(데이터)를 가지는가
  
  - 조작법(method) ; 어떤 행위(함수)를 할 수 있나

### 2) 기본 문법

- 클래스 정의 : class Myclass:

- 인스턴스 생성 : my_instance = Myclass()

- 메서드 호출 : my_instance.my_method()

- 속성 : my_instance.my_attribute

- 객체 비교
  
  - == : 동등한(equal) / 두 객체가 같아 보이지만 동일 대상을 가리킨다 X
  
  - is : 동일한(identical)
  
  ```python
  a = [1,2]
  b = [1,2]
  c = a
  print(a == b, a is b) # True False
  print(a == c, a is c) # True True
  ```

### 3) OOP 속성

- 인스턴스 변수 : 인스턴스가 개인적으로 가지고 있는 속성, 각 인스턴스들의 고유변수
  
  - 생성자 메서드 `__init__`에서 `self.<name>`으로 정의
  
  - 생성 이후 `<instance>.<name>`으로 접근
    
    > def \_\_init__(self, name): << 인스턴스 변수 정의

- 클래스 변수 : 한 클래스의 모든 인스턴스가 공유하는 값
  
  - ex) 특정 사이트의 User 수 등
  
  - 클래스 선언 내부에서 정의, `<class>.<name>`으로 접근/할당
    
    > Class Circle():
    > 
    >     pi = e.14
    > 
    > Circle.pi

- 클래스 변수와 인스턴스 변수
  
  ```python
  class Circle():
      pi = 3.14
      def __init__(self, r):
          self.r = r
  
  c = Circle(5)
  print(Circle.pi, c.pi) # 3.14 3.14
  Circle.pi = 5
  print(Circle.pi, c.pi) # 5 5
  c.pi = 4
  print(Circle.pi, c.pi) # 5 4
  ```

- L.sort() : 원본을 정렬 / sorted(L) : 원본은 그대로

- L.reverse() : 원본을 뒤집음

### 4) OOP 메서드

- 메서드 : 특정 데이터 타입/클래스의 객체에 공통적용 가능한 행위(함수)

- 메서드의 종류 : 인스턴스 메서드, 클래스 메서드, 정적 메서드
  
  - 인스턴스 메서드
    
    - 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
    
    - 클래스 내부에 정의되는 매서드의 기본
    
    - 호출 시 첫번째 인자로 self가 전달됨
      
      - self : 인스턴스 자기 자신
      
      - 매개변수 이름으로 self를 첫 번째 인자로 정의(암묵적 규칙)
  
  - 생성자(constructor) 매서드 / `__init__`
    
    - 인스턴스 객체가 생성될 때 자동 호출되는 메서드
    
    - 초기값을 설정
  
  - 매직 메서드 : \_\_ 있는 메서드, 특수동작용 / 스페셜 메서드라고도 불림
  
  - 소멸자(destructor) 메서드 : 인스턴스 소멸될 때 호출되는 메서드 / `__del__`
  
  - 클래스 메서드
    
    - `@classmethod` 데코레이터를 사용하여 정의
    
    - 호출 시, 첫 번째 인자로 cls가 전달됨
    
    - 데코레이터
      
      - 함수를 어떤 함수로 꾸며 새로운 기능 부여
      
      - `@데코레이터(함수명)` 형태로 함수 위에 작성
      
      - 순서대로 적용, 순서 중요
        
        ```python
        def hello():
            ~~~
        def add_print():
            def wrapper():
                ~~~
            return wrapper
        print_hello = add_print(hello)
        ######
        def add_print()
            def wrapper():
                ~~~
            return wrapper
        @add_print
        def print_hello:
            ~~~
        print_hello()
        ```
  
  - 클래스 메서드와 인스턴스 메서드
    
    - 클래스 > 클래스 변수 / 인스턴스 > 인스턴스 변수 사용
    
    - 클래스에서 인스턴스 메서드 사용 불가 / 인스터스는 둘 다 가능
  
  - 스태틱 메서드
    
    - 인스턴스/클래스 변수 전혀 안 다루는 메서드
    
    - 속성을 다루지 않고 단지 기능만을 하는 메서드 정의할 때 사용
    
    - `@staticmethod` 데코러이터 통해 정의
      
      ```python
      class Myclass:
          @staticmethod
          def static_method(arg1, ...):
      Myclass.static_method(...)
      ```

- 인스턴스와 클래스 간의 namespace : 인스가 안, 클래스가 밖

### 5) 메서드 정리

- 인스턴스 메서드 : self 매개변수를 통해 인스턴스 조작

- 클래스 메서드 : cls 매개변수 통해 클래스 조작

- 스태틱 메서드 : 클래스/인스턴스 변수 사용 안 함
  
  ```python
  class Myclass:
      def method(self):
  
      @classmethod
      def classmethod(cls):
  
      @staticmethod
      def staticmethod():
  ```

## 3. 객체지향의 핵심개념

### 1) 추상화

- 현실 세계를 프로그램 설계에 반영
  
  - 복잡한건 숨기고 필요한 것만

### 2) 상속

- 두 클래스 사이 부모-자식 관계 정립

- 클래스는 상속 가능 / 모든 파이썬 클래스는 object 상속받음
  
  ex) Person class의 talk를 내부 class인 Student에서 사용

- 다중 상속 : 2개 이상 클래스를 상속 받는 경우 / 중복 시 순서에 의해 결정
  
  ```python
  class Mom(Person):
      gene = 'XX'
  class Dad(Person):
      gene = 'XY'
  class Child(Dad, Mom):
  baby = Child('아가')
  print(baby.gene) #XY
  ```

- 상속 관련 함수와 메서드
  
  - isinstance(object, classinfo) : classinfo의 instance 혹은 subclass일 경우 True
  
  - issubclass(class, classinfo) : class가 classinfo의 subclass면 True
  
  - super() : 자식클래스에서 부모클래스 사용할 때
  
  - .mro() (Method Resolution Order)
    
    - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인용

- 메서드 오버라이딩을 통해 클래스에서 재정의 가능

### 3) 다형성

- 여러 모양을 뜻하는 그리스어

- 동일한 메서드가 클래스에 따라 다르게 행동할 수 있음

- 다른 클래스에 속한 객체들이 동일 메세지에 대해 다르게 반응할 수 있음

- 메서드 오버라이딩
  
  - 상속받은 메서드 재정의
    
    ```python
    class Person:
        def talk(self):
            print(f'반갑습니다. {self.name}입니다.')
    class Professor(Person):
        def talk(self):
            print(f'{self.name}일세')
    class Student(Person):
        def talk(self):
            super().talk()
            print(f'저는 학생입니다.')
    
    p1 = Professor('김교수')
    p1.talk() # 김교수일세.
    s1 = Student('여학생')
    s1.talk() # 반갑습니다. 여학생입니다. // 저는 학생입니다.
    ```

### 4) 캡슐화

- 객체의 일부 구현 내용에 대해 외부로부터의 직접적 엑세스 차단
  
  - ex) 주민등록번호

- 파이썬에서 암묵적 존재, 언어적으로는 존재하지 않음

- 종류
  
  - Public Access Modifier
  
  - Protected Access Modifier
  
  - Private Access Modifier

- Public Member
  
  - 언더바 없이 시작하는 메서드/속성
  
  - 어디서나 호출 가능, 하위 클래스 override 허용

- Protected Member
  
  - 언더바 한 개로 시작하는 메서드/속성
  
  - 암묵적 규칙으로 부모 클래스 내부와 자식 클래스에서만 호출 가능

- Private Member
  
  - 언더바 2개로 시작하는 메서드/속성
  
  - 본 클래스 내부에서만 사용 가능
  
  - 하위클래스 상속/호출 불가(에러 뜸)
  
  - 외부 호출 불가능(에러 뜸)

- getter 메서드 : 변수의 값 읽는 메서드(`@property` 데코레이터 사용)

- setter 메서드 : 변수의 값을 설정하는 성격의 메서드(`@변수.setter` 사용)
  
  ```python
  class Person:
      def __init__(self, age):
          self._age = age
      @property
      def age(self):
          return self._age
      @age.setter
      def age(self, new_age):
          if new_age <= 19:
              raise ValueError('Too Young for SSAFY')
              return
          self._age = new_age
  p1 = Person(20)
  peint(p1.age) # getter를 써서 _age도 잘 나옴
  # setter를 써서 쉊ㅇ도 가능
  p1.age = 30
  ```

## 4. 에러/예외 처리

### 1) 디버깅

- 버그란 : 1945년 그레이스 호퍼가 발견, Mark II 컴퓨터 회로에 나방이 들어가 비정상적으로 동작해 유래

- 디버깅 : 잘못된 프로그램을 수정하는 것
  
  - print 함수 활용
  - 개발 환경(text editor, IDE) 등에서 제공하는 기능(breakpoint, 변수 조회 등) 활용
  - 뇌컴파일, 눈디버깅

### 2) 에러와 예외

- 문법 에러(Syntex Error) : 파일이름, 줄번호, ^ 통해 발생한 위치 표현
  
  - Invalid syntax : 문법오류
  
  - assign to literal : 잘못된 할당
  
  - EOL(End of Line) : 괄호 제대로 안 친 경우
  
  - EOF(End of File)

- 예외(Expection)
  
  - 실행 중 감지되는 에러
  
  - 실행 도중 예상치 못한 상황을 맞이하면 실행을 멈춤(문법적으로 맞더라도)
  
  - 예외는 여러 타입으로 나타남
    
    - ZeroDivision Error : /0
    
    - NameError : not defined(namespace에 이름이 없는 경우)
    
    - TypeError
      
      - 타입 불일치(int, str 덧셈 등)
      
      - argument 누락, 개수초과, 타입 불일치
    
    - ValueError : 타입은 올바르나 값이 적절치 않을 때 ex)int('3.5')
    
    - IndexError : Index가 존재하지 않을 때
    
    - KeyError : Key가 존재하지 않을 때
    
    - ModuleNotFoundError : 존재하지 않는 모듈
    
    - ImportError : 모듈은 있는데 클래스/함수가 존재하지 않음
    
    - KeyboardInterrupt : 임의로 프로그램 종료
    
    - IndentationError : Indentation(들여쓰기)이 적절치 않을 경우

### 2) 예외 처리

- try문 / except절 : try (오류 있을 수 있는 코드) except(오류 났을 때)
  
  ```python
  try:
      명령문
  except 예외그룹1 as 변수1:
      예외 명령문
  except 예외그룹2 as 변수2:
      예외 명령문
  else:
      이외 명령
  finally:
      최명령문
  ```

- as를 통해 기존 에러 메세지 사용 가능

- else는 except 이외, finally는 공통
