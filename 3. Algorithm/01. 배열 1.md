# 1. APS(Algorithm Problem Solving) 기본

## 목차

1. 배열 1(Array 1)
   
   - 알고리즘
   
   - 배열
   
   - Bubble Sort
   
   - Counting Sort
   
   - 완전검색
   
   - Greedy Algorithm

## 1. 배열 1

### 1) 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

- 의사코드(Pseudocode)와 순서도

- 좋은 알고리즘
  
  1. 정확성 : 얼마나 정확하게 하나
  
  2. 작업량 : 얼마나 적은 연산으로 하나
  
  3. 메모리 사용량 : 얼마나 적은 메모리를 사용하나
  
  4. 단순성 : 얼마나 단순한가
  
  5. 최적성 : 최적화되었는가

. 시간복잡도 : 실제 걸리는 시간을 측정, 명령문 개수 계산

. Big-Oh 표기법 : n에 대해서만, 계수 생략

  . O(3n+2) = O(3n) = O(n)

### 2) 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 필요성
  
  - 일일이 다른 변수 지정해 접근하는건 비효율적

- 1차원 배열의 선언
  
  - `Arr = list()` `Arr = []` `Arr = [1,2,3]` `Arr = [0]*10`

- 접근
  
  - `Arr[0] = 10` Arr의 0번 원소에 10 저장
  
  - `Arr[idx] = 20` Arr의 idx번 원소에 20 저장

- 활용 예제 : Gravity
  
  상자들이 쌓여 있는 방이 있다, 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.
  
  - 중력은 회전 완료 후 적용
  
  - 상자들은 모두 한쪽 벽면에 붙어진 상태로 2차원 형태
  
  - 가로세로는 항상 100

### 3) 정렬

- 2개 이상의 자료를 기준에 의해 작은 값>큰 값 혹은 반대로 재배열하는 것

- 종류 : Bubble, Counting, Selection, Quiick, Insertion, Merge

#### a) Bubble Sort

- 인접한 두 개의 원소를 비교하며 계속 교환하는 방식

- 시간 복잡도 O(n²)

- Pseudo Code
  
  ```
  BubbleSort(a,N)
      for i : N-1 -> 1
          for j : 0 -> N-1
              if a[j] > a[j+1]
                  a[j] <-> a[j+1]
  ```
  
  ```python
  def Bubblesort(a, N) : 
      for i in range(N-1, 0, -1):
          for j in range(0, i):
              if a[j] > a[j+1]: 
                  a[j], a[j+1] = a[j+1], a[j]
  ```

#### b) Counting Sort

1. 발생횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장

2. 정렬된 집합에서 각 항목의 앞에 위치할 항목 개수 반영 위해 counts 원소 조정
   
   - ex) 1, 3, 1, 1, 2 >> 1, 4, 5, 6, 8

3. counts[i] = n일 때 n을 감소시키고 n에 i 삽입
- Counting Sort는 대략 100만개 정도에서 씀

- 알고리즘
  
  ```python
  def Counting_Sort(A, B, k):
    # A[] : 입력 배열(1~k)
    # B[] : 정렬 배열
    # C[] : 카운트 배열
  
    C = [0] * (k + 1)
    for i in range(0, len(A)):
        C[A[i]] += 1
  
    for i in range(1, len(C)):
        C[i] += C[i-1]
  
    for i in range(len(B), -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
  ```

### 4) 완전 검색 (Exaustive Search)

- 모든 경우의 수를 나열/확인하는 기법

- Brute-forcem generate-and-test 기법이라고도 부름

- Baby-gin Game
  
  - 0~9 중 임의 6장을 뽑을 때 3장 카드 연속일 때 run, 3장 동일 번호일 때 triplet
  
  - 6장의 카드가 run과 triplet로만 구성된 경우 baby-gin
  
  - 6자리 숫자를 받아 baby-gin 여부를 판단하는 프로그램 구성하라
  
  - ex)
    
    - 667767 : baby-gin(666, 777)
    
    - 054060 : baby-gin(000, 456)
    
    - 101123 : X
  
  - 모든 경우의 순열 나열 > 3자리씩 잘라 확인 후 baby-gin 확인

- 순열 : 다른 것 중 몇 개 를 뽑아 한 줄로 나열 (nPr)

### 5) 탐욕 알고리즘 (Greedy Algorithm)

- 최적해를 구하는 데 사용하는 근시안적 방법

- 여러 경우 중 하나를 결정할 때마다 순간에 최적이라고 생각되는걸 선택해나가는 방식

- 동작 과정
  
  1) 해 선택 : 현재 상태에서 부분 문제 최적해를 구한 뒤 부분해 집합(Solution Set)에 추가
  
  2) 실행 가능성 검사 : 새로운 부분해 집합이 실행가능한지 확인
  
  3) 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인

) 예시 : 거스름돈 줄이기

  ) 어떻게 손님에게 거스름돈으로 주는 지폐/동전 개수 최소화할까?

    1. 큰 단위의 동전을 먼저 넣는다.
    
    2. 액수 초과하는지 확인, 초과하면 하나 빼고 한 단계 적은 동전 넣음

. Baby-gin 완전검색 아닌 방법으로 풀기

  . 각 원소 체크해 run, triplet 확인

    . ex) run 조사 후 run 완전삭제
    
    ```python
    num = 456789
    c = [0] * 12
    
    for i in range(6):
        c[num % 10] += 1
        num //= 10
    
    
    i = 0
    tri = run = 0
    shile i < 10 : 
        if c[i] >= 3:
            c[i] -= 3
            tri += 1
            continue
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    
    if run + tri == 2 : print('Baby Gin')
    else : print('Lose')
    ```
