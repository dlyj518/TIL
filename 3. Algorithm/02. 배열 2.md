# 1. APS(Algorithm Problem Solving) 기본

## 목차

1. 배열 2(Array 2)
   
   - 2차원 배열
   
   - 부분집합 생성
   
   - 바이너리 서치
   
   - 셀렉션 알고리즘
   
   - 선택 정렬

## 1. 배열 2

### 1) 2차원 배열의 선언

- 1차원 List를 묶어놓은 List

- arr = [[0,1,2,3],[4,5,6,7]]

- 배열 순회 : n×m 배열 모든 원소를 빠짐없이 조사하는 방법
  
  - 행 우선 순회
    
    ```python
    for i in range(n):
        for j in range(m):
            Array[i][j]
    ```
  
  - 열 우선 순회
    
    ```python
    for j in range(n):
        for i in range(m):
            Array[i][j]
    ```
  
  - 지그재그 순회
    
    ```python
    for i in range(n):
        for j in range(m):
            Array[i][j + (m-1-2*j) * (i%2)]
    ```
  
  - 델타를 통한 탐색 : 한 좌표에서 4방향의 인접배열 요소 탐색
    
    ```python
    di = [0,0,-1,1]
    dj = [-1,1,0,0]
    for i in range(n):
        for j in range(m):
            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                if 0<=ni<=n and 0<=nj<n : test(arr[ni][nj])
    ```
  
  - 전치행렬
    
    ```python
    for i in range(n):
        for j in range(n):
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```
  
  - 연습문제 : 5×5 배열에 25개 숫자로 초기화한 후 각 요소에 대해 이웃한 요소와의 차의 절댓값을 구하여 총합을 구하시오.
    
    ```python
    arr = [[1,2,3,4,5], [6,7,8,9,10], [11,12,13,14,15],
        [16,17,18,19,20], [21,22,23,24,25]]
    di = [0,0,-1,1]
    dj = [-1,1,0,0]
    s = 0
    for i in range(n):
        for j in range(m):
            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                if 0<=ni<n and 0<=nj<n:
                    s += abs(arr[ni][nj]-arr[i][j])
    ```

### 2) 부분집합 문제

- 유한 개 정수 집합이 있을 때, 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 존재하는지 알아내는 문제
  
  - ex) [-7,-3,-2,5,8] : [-3,-2,5]

- 부분집합의 수 : 넣거나, 넣지 않거나 > 2ⁿ

- 각 원소가 부분집합에 포함되었는지를 확인하고 생성하는 방법
  
  ```python
  bit = [0,0,0,0]
  for i in range(2):
      bit[0] = i
      for j in range(2):
          bit[1] = j
          for k in range(2):
              bit[2] = k
              for l in range(2):
                  bit[3] = l
                  print_subset(bit)
  ```

- 비트 연산자
  
  - & : 비트 단위 AND
  
  - | : 비트 단위 OR
  
  - << : 피연산자 비트 열을 왼쪽으로 이동 // a << b == a * 2^b
  
  - \>\>: 피연산자 비트 열을 오른쪽으로 이동 // a>>b == a // 2^b
    
    - 1 << n : 원소가 n개일 경우의 모든 부분집합 수 의미
    
    - i & (1<<j) : i의 j번째 비트가 1인지 확인

- 간결한 부분집합 생성
  
  ```python
  arr = [3,6,7,1,5,4]
  n = len(arr)
  for i in range(1<<n) :
      for j in range(n) :
          if i & (1<<j) :
              print(arr[j], end=', ')
      print()
  print()
  ```

### 3) 검색

- 저장된 자료 중 원하는 항목을 찾는 작업
  
  - 순차검색, 이진검색, 해쉬 등

- 순차검색
  
  - 일렬로 되어있는 자료를 순서대로 검색하는 방법
  
  - 간단하고 직관적, 수가 많으면 수행시간이 급격히 증가
  
  - 정렬되지 않은 경우
    
    - 순서대로 같은지 검색, 같으면 인덱스 리턴
    
    - 찾고자 하는 원소 순서에 따라 비교횟수가 결정
    
    - 시간 복잡도 O(n)
    
    ```python
    def sequentialSearch(a, n, key):
        i = 0
        while i<n and a[i] != key:
            i += 1
        if i<n : return i
        else: return -1
    ```
  
  - 정렬된 경우
    
    - 순차검색하면서 키값 비교해 원소 키값이 검색대상 키값보다 크면 종료
    
    - ex) 10 찾는데 비교 원소가 11이면 종료
    
    - 평균 비교횟수 절반으로 줄어듬
    
    - 시간 복잡도 O(n)
    
    ```python
    def sequentialSearch2(a, n, key):
        i=0
        while i<n and a[i]<key: i += 1
        if i<n and a[i] == key: return i
        else: return -1
    ```

- 이진 검색
  
  - 가운데 항목의 키값과 비교 후 다음 검색 위치 결정하고를 반복
  
  - 자료는 정렬되어야 함
  
  - 검색과정
    
    - 중앙 원소와 목표값 비교
    
    - 목표값이 작으면 왼쪽 반에서 동일하게, 크면 오른쪽에서 수행
    
    - 찾을 때까지 반복
    
    ```python
    def binarySearch(a, n, key):
        start = 0
        end = n-1
        while start <= end:
            middle = (start + end) // 2
            if a[middle] == key : return True
            elif a[middle] > key : end = middle - 1
            else : start = middle + 1
        return false
    ```
  
  - 재귀 이용
    
    ```python
    def binarySearch2(a, low, high, key):
        if low > high : return False
        else : 
            middle = (low+high) // 2
            if key == a[middle] : return True
            elif key < a[middle] :
                return binarySearch2(a, low, middle-1, key)
            elif key > a[middle] :
                return binarySearch2(a, middle+1, high, key)
    ```

### 4) 선택 정렬(Selection Sort)

- 인덱스 : 데이터베이스에서 유래, 테이블 동작 속도를 높여주는 자료구조

- 주어진 자료들 중 가장 작은 값의 원소부터 차례로 선택하여 위치를 교환하는 방식

- 과정
  
  - 최소값을 찾는다.
  
  - 리스트 가장 앞 위치한 값과 교환
  
  - 맨 처음 제외하고 다시 실행
  
  - 시간복잡도 O(n²)
  
  ```python
  def SelectionSort(a,n) :
      for i in range(n-1):
          minidx = i
              for j in range(i+1, n):
                  if a[minidx] > a[j]
                      minidx = j
              a[i], a[minmax] = a[minidx, a[i]
  ```

- Selection Algorithm
  
  - 저장되어 있는 자료로부터 k번째로 큰/작은 원소를 찾는 방법
  
  - 정렬 알고리즘을 통해 정렬 > 원하는 순서 원소 가져오기
  
  ```python
  def select(arr, k):
      for i in range(k):
          minindex = i
          for j in range(i+1, len(arr)):
              if arr[minindex] > arr[j]
                  minindex = j
          arr[i], arr[minindex] = arr[minindex], arr[i]
      return arr[k-1]
  ```
