# 9. APS_응용 : 완전탐색, 그리디

## 목차

1. 반복(Iteration)과 재귀(Recursion)

2. 완전검색기법

3. 순열

4. 부분 집합

5. 조합

6. 탐욕 알고리즘

7. 활동 선택 문제

8. Baby-jin

## 1. 반복과 재귀

- 반복과 재귀는 유사한 작업 수행 가능

- 반복
  
  - 초기화 : 조건 검사에 사용할 변수 초기값 설정
  
  - 조건 검사
  
  - 반복 명령문 실행
  
  - 업데이트 : 무한루프가 되지 않게 조건이 거짓이 되게 함

- 재귀
  
  - 하나 또는 그 이상의 기본 경우(basis case/rule) : 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할
  
  - 하나 또는 그 이상의 유도된 경우(inductive case/rule) : 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

- 재귀는 설계가 간단하고 자연스럽지만 반복보다 더 많은 메모리/연산 필요

- n이 커질수록 재귀가 반복에 비해 비효율적일 수 있음

- 비교
  
  |          | 재귀                     | 반복                |
  | -------- | ---------------------- | ----------------- |
  | 종료       | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건        |
  | 수행 시간    | (상대적으로) 느림             | 빠름                |
  | 메모리 공간   | (상대적으로) 많이 사용          | 적게 사용             |
  | 소스 코드 길이 | 짧고 간결                  | 긺                 |
  | 소스 코드 형태 | 선택 구조 (if-else)        | 반복 구조(for, while) |
  | 무한 반복 시  | 스택 오버플로우               | CPU 반복 점유         |

- 연습문제 1 : 선택정렬 함수를 재귀적 알고리즘으로 작성하시오.

## 2. 완전 검색 기법

- Baby-gin Game : 6장의 카드가 triplet/run으로만 이루어지는 경우 찾기
  
  - brute-force : 가장 간단하고 쉬운 접근법
    
    - 대부분 문제에 적용 가능
    
    - 빠른 시간에 설계 가능
    
    - 자료의 크기가 작으면 유용
    
    - 알고리즘 효율성 판단하기 위한 척도로 사용
    
    - 속도는 느리지만 해답 못 찾을 확률이 작음
    
    - 이를 기반으로 그리디/DP를 이용해 효율적 알고리즘 찾을 수 있음
  
  - 완전 검색
    
    - 조합적 문제에 대한 brute-force 방법

## 3. 순열

- 서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것

- $_nP_r = n\times(n-1)\times\dots\times(n-r+1)$

- $_nP_n = n!$

- 다수 알고리즘 문제는 순서화된 요소 집합에서 최선의 방법을 찾는 것과 관련이 있다. ex) TSP(Traveling Salesman Problem)

- N개의 요소들에 대해서 n!개의 순열들이 존재

- 단순 순열 생성 방법
  
  ```python
  for i1 in range(1,4):
      for i2 in range(1,4):
          if i2 != i1:
              for i3 in range(1,4):
                  if i3 != i1 and i3 != i2: print(i1,i2,i3)
  ```

- 사전석 순서(Lexicographic-Order)

- 최소 변경 방법(Minimum-exchange requirement)
  
  - 이전 상태에서 2개 요소 교환을 통해 생성
  
  - 123 > 3**2**1 > 23**1** > **2**13 > 3**1**2 > 13**2**

- 최소변경을 통해 다음 순열 생성 방법
  
  - 1950년대의 교회 종소리 패턴과도 유사
  
  - Johnson-Trotter 알고리즘
  
  - 12-23-34-12-34-23-12-34-12-...

- 재귀를 통한 순열 생성
  
  ```python
  # p[] : 데이터 배열
    # k : 원소의 개수, n : 선택된 원소 수
    def perm(n,k):
        if n == k:
            print array
        else:
            for i in range(n, k):
                p[n], p[i] = p[i], p[k]
                perm(n+1, k)
                p[n], p[i] = p[i], p[k]
	```

- 연습문제2 : 6자리 숫자에 대해 완전검색을 적용해 Baby-gin을 검사하시오.

## 4. 부분 집합

- 집합에 포함된 원소들을 선택하는 것

- 다수의 중요 알고리즘이 최적의 부분집합을 찾는 것 ex) 배낭 짐싸기(knapsack)

- N개의 원소를 포함한 집합

- 단순 방법
  
  ```python
  for i1 in range(2):
      bit[0] = i1
      for i2 in range(2):
          bit[1] = i2
          for i3 in range(2):
              bit[2] = i3
              for i4 in range(4):
                  bit[3] = i4
                  print(array)
  ```

- 바이너리 카운팅 통한 사전적 순서(Lexicograpic Order)
  
  - 가장 자연스러운 방법
  
  - 바이너리 카운팅
    
    - 사전적 순서를 하기 위한 가장 쉬운 방법
    
    - n개의 비트열 이용, n번째가 1이면 n번째 원소가 포함
      
      ```python
      n = len(arr)
      for i in range(1<<n):
          for j in range(n):
              if i & (i<<j): print(arr[j], end=' ')
          print()
      ```

## 5. 조합

- n개 중 r개를 순서 없이 골라낸 것

- $_nC_r = {n!\over (n-r)!r!} = _{n-1}C_{r-1}+_{n-1}C_r$

- 재귀 이용 알고리즘
  
  ```python
  def comb(n,r):
      if r == 0: print(arr)
      elif n < r: return
      else:
          tr[r-1] = an[n-1]
          comb(n-1, r-1)
          comb(n-1, r)
  ```

- 10개 원소 중 3개 고르는 조합
  
  ```python
  for i in range(8):
      for j in range(i+1, 9):
          for k in range(j+1, 10):
              f(a[i], a[j], a[k])
  ```

- n개에서 r개 고르는 조합(재귀)
  
  ```python
  def ncr(n,r,s):
      if r == 0: print(*comb)
      else:
          for i in range(s, n-r+1):
              comb[r-1] = A[i]
              ncr(n, r-1, i+1)
  ```

- 연습문제 3 :부분집합 합 문제 구현
  
  - 아래 10개 정수 집합에 대한 모든 부분 집합 중 원소의 합이 0이 되는 부분집합을 모두 출력하시오.

## 6. 탐욕 알고리즘

- 문제 : 어떻게 하면 손님에게 거스름돈으로 주는 지폐/동전 개수를 최소화할까?

- 머리속에 떠오르는 생각을 검증 없이 바로 구현

- 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식

- 최종 해답을 만든다고 하여 그것이 최적이라는 보장은 없음

- 한 번 선택된 것은 번복하지 않음

- 동작과정
  
  1. 해 선택 : 부분 문제의 최적해를 구해 Solution Set에 추가
  
  2. 실행 가능성 검사 : 새로운 Solution Set이 실행 가능한지 확인
  
  3. 해 검사 : 새로운 Solution Set이 문제의 해가 되는지 확인

. 그리디 거스름돈 줄이기
  
  1. 해 선택 : 단위가 큰 동전으로만 거스름돈을 만들면 줄어들기 때문에 고를 수 있는 최대 동전을 거스름돈에 추가
  
  2. 실행 가능성 검사 : 거스름돈이 액수를 초과하는지 확인, 초과하면 취소 후 한 단계 작은 동전 추가
  
  3. 해 검사 : 거스름돈\=\=액수

. 최적해 보장 없음
  
  . ex) 1200원 / 동전 500/400/100원일 경우 1/0/3으로 반환

. 짐 싸기 (Knapsack)
  
  . 총 무게가 정해진 배낭, 무게를 초과하지 않으면서 최대값으로 담아야 함
  
  . 0-1 Knapsack : 물건을 못 쪼개는 경우
  
  . Fractional Knapsack : 쪼갤 수 있는 경우
  
  . 0-1 Knapsack에 대한 완전검색
   
	- 모든 부분집합 구한 뒤, W 초과하는 집합 버린 나머지에서 총 값이 가장 큰 것 구하기
  
  . 0-1 Knapsack 그리디
    
    . 비싼 물건부터 채운다 >> 최적이 아님
    
    . 가벼운 물건부터 채운다 >> 역시 아님
    
    . 무게 당 값이 높은 순서로 채운다 >> 구하기 어려움
      
      . Fractional Knapsack에서는 가능

## 7. 활동 선택 문제

- 회의실 배정하기 : 가능한 많은 회의가 열리기 위한 회의 배정 문제

- 그리디 
  
  1. 하위문제(Subproblem) S_{i,j}에서 종료시간이 가장 빠른 활동 a_m을 선택
  
  2. $S_{i,m} = \empty$므로 $a_m$을 선택하면 하위문제 $S_{m,j}$가 남는다.
  
  3. 1~2 반복    

. 그리디 알고리즘
  
  ```python
  sort(A, key=finish_time)
  s = A[1]
  j = 1
  for i in range(2, n+1)
      if s[i] >= finish_time:
          s = s & A[i]; j = i
  ```

. 재귀 알고리즘
  
  ```python
  def rec(i,j):
      m = i+1
      while m<j and s[m] < f[i]: m += 1
      if m<j: return a[m] & rec(m, j)
      else: return {}
  ```

. 그리디와  DP의 비교
  
  | 그리디                | DP                |
  | ------------------ | ----------------- |
  | 매 단계에서 가장 좋게 보이는 것 | 하위 문제의 해를 기반으로 선택 |
  | 하위 풀기 전에 그리디 우선    | 하위가 우선 해결         |
  | Top-down           | Bottom-Up         |
  | 빠르고 간결             | 느리고 복잡            |

. 대표적 탐욕 기법 알고리즘
  
  . Prim : 최소 신장 트리(MST) / 서브트리를 확장하면서 MST 찾기
  
  . Kruskal : MST / 사이클 없는 서브그래프를 확장하면서 찾기
  
  . Dijkstra : 주어진 정점에서 다른 정점들에 대한 최단경로 / 가까운 정점들을 반복해서 찾기
  
  . Guffman tree & code : 문자들의 빈도수에 따라 코드값 부여 / 빈도 낮은 문자부터 선택해 이진트리 완성 후 코드값 부여

## 8. Baby-gin

- 그리디로 풀기 : run/triplet 조사 후 확인

- 
