# 8. APS 응용

## 목차

1. 분할정복
2. 퀵 정렬
3. 이진 검색
4. 백트래킹
5. 트리

## 1. 분할정복
- 가짜 동전 찾기
	- n개 동전 중 가짜 동전 하나를 양팔저울로 찾기
- 유래
	- 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략
	- 전력이 우세한 연합군을 공격하기 위해 중앙부로 들어가 둘로 나눈 후 한 부분씩 격파
- 전략
	- 분할(Devide) : 문제를 작은 부분으로 나눔
	- 정복(Conquer) : 나눈 작은 문제를 각각 해결
	- 통합(Combine) : 해결된 해답을 모음
- 거듭제곱 비교
	- 반복 알고리즘 : O(n)
		- Cⁿ 구하기
	```python
	def Iter_Power(x,n):
		rst = 1
		for i in range(1, n):
			result *= x
		return result
	```
	- 분할 정복 기반
		- $$C^n = 
		\begin{cases}
			C^{n/2}\times C^{n/2}, & \mbox{if }n\mbox{ is even} \\
			C^{(n-1)/2}\times C^{(n-1)/2}\times C, & \mbox{if }n\mbox{ is odd}
		\end{cases}
	$$
	```python
		def Ruc_Power(x, n):
			if n == 1: return x
			if n % 2 == 0:
				y = Rec_Power(x, n/2)
				return y*y
			else:
				y = Rec_Power(x, (n-1)/2)\
				return y * y * x
	```
- 병합 정렬(Merge Sort)
	- 자료를 최소 단위의 문제까지 나눈 후 차례대로 정렬해 결과를 얻어냄
	- top-down 방식
	- 시간복잡도 O(n log n)
	- 알고리즘
	```python
		def merge_sort(m):
			if len(m) == 1: return m
			mid = len(m) // 2
			l = m[:mid]
			r = m[mid:]
			l = merge_sort(l)
			r = merge_sort(r)
			return merge(l, r)
		def merge(l, r):
			while len(l) > 0 or len(r) > 0:
				if len(l) > 0 or len(r) > 0:
					if l[0] <= r[0]: result.append(l.pop(0))
					else: result.append(r.pop(0))
				elif len(l) > 0
					result.append(l.pop[0])
				elif len(r) > 0
					result.append(r.pop[0])
			return result
	```

## 2. 퀵 정렬
- 주어진 배열을 분할 후 각각을 정렬한다.
	- 병합은 그냥 2개로 나누는 반면, 퀵 정렬은 pivot item 기준으로 작은 것은 왼편, 큰 것은 우편으로 나눈다
	- 각 부분 정렬이 끝난 후, 병합정렬과 달리 따로 병합 과정이 필요없다.
- 알고리즘
	```python
		def quicksort(A, l, r):
			if l < r:
				s = partition(A, l, r)
				quicksort(A, l, s - 1)
				quicksort(A, s + 1, r)
		# Hoare-Partition 알고리즘
		def partition(A, l, r):
			p = A[l]
			i, j = l, r
			while i <= j:
				while i <= j and A[i] <= p: i += 1
				while i <= j and A[j] >= p: j -= 1	
				if i < j: A[i], A[j] = A[j], A[i]
			a[l], a[j] = a[j], a[l]
			return j
		# Lomuto partition 알고리즘
		def partition(A, p, r):
			x = A[r]
			i = p - 1
			for j in range(p, r):
				if A[j] <= x: i += 1; A[i], A[j] = A[j], A[i]
			A[i+1], A[j] = A[j], A[i+1]
	```

## 3. 이진 검색
- 병뚜껑 속 숫자 게임
	- 병뚜껑 속 숫자를 업다운으로 맞힘, 맞힌 사람이 벌주
- 자료 가운데 키 값과 비교해 위치를 결정하고 검색을 진행하는 방법
- 자료가 정렬된 상태여야 함
- 검색과정
	- 중앙 원소 골라서 목표값과 비교
	- 작으면 좌측으로, 크다면 우측으로 새로 검색
	- 찾을 때까지 반복
- 알고리즘
	- 반복
	```python
		def binsearch(n, S, key):
			l = 0
			h = n - 1
			while l <= h:
				mid = l + (h-l) // 2
				if S[mid] == key: return mid
				elif S[mid] > key: h = mid - 1
				else: l = mid + 1
			return -1				
	```
	- 재귀
	```python
		def binsearch(A, l, h, key):
			if l > h: return -1
			else:
				mid = (l+h) // 2
			if key == A[mid]: return mid
			elif A[mid] > key: return binsearch(A, l, m - 1, key)
			else: return binsearch(A, m + 1, h, key)
	```
- 분할정복의 활용
	- 병합 정렬은 외부 정렬의 기본이 되는 정렬 알고리즘
	- 퀵 정렬은 매우 큰 입력 데이터에 대해 좋은 성능은 보이는 알고리즘
- 연습문제 1 : 배열의 데이터를 퀵 정렬하는 함수를 작성하고 테스트 해보시오.
	입력 예 : 11, 45, 23 81, 28 34 // 11, 45, 22, 81, 23, 34, 99, 22, 17, 8

## 4. 백트래킹
- N-Queen 문제 : 서로 위협하지 않게 Queen 배치
- 개념
	- 여러 선택지 중 하나 선택
	- 선택 후 선택지들의 집합이 생성
	- 이런 선택을 반복하며 최종 상태에 도달
- DFS와의 차이
	- 해결책이 아니다 싶으면 따라가지 않으므로 횟수 줄임(Punning, 가지치기)
- 8-Queens 문제
	- 후보 해의 개수 : $_64C_8 = 4,426,165,368$ , 실제 해는 92개
	- 알고리즘
	```python
		def checknode(v):
			if promising(v):
				if v in solution:
					print(solution)
				else:
					for u in v: checknode(u)
	```
	- 4-Queen일 때 DFS 155노드 / 백트래킹 27노드
- 연습문제2 : 1~10의 powerset 중 원소의 합이 10인 부분집합을 모두 출력하시오.

## 4. 트리
- 계산기 : 그래프를 순회하여 수식을 계산하시오.
- 연습문제 : 트리 순회
	- 간선 개수 v와 간선이 주어졌을 때 전/중/후위순회하고 노드번호 출력
- 이진 탐색 트리
	- 루트에서 탐색 시작, x를 k와 비교
	- 작으면 좌측, 크면 우측 서브트리에서 탐색
	- 연산
		- 삽입 : 탐색 실패한 위치에 삽입
		- 삭제 : 탐색 > 삭제 > 후속처리/이동
	- 성능
		- 탐색, 삽입, 삭제 : O(h)
		- 평균 O(log n), 최악 O(n) (편향 이진 트리)
	- 힙 : 키 값이 가장 큰/작은 노드 찾기 위한 자료구조
		- 완전 이진 트리