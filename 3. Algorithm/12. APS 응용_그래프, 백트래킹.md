# 11. APS 응용 : 그래프, 백트래킹

## 목차

1. 그래프 기본
2. DFS
3. BFS
4. 서로소 집합들
5. 최소 비용 신장 트리 (MST)
6. 최단 경로

## 1. 그래프 기본
- 이이템들과 이들 사이의 연결 관계를 표현
- 정점들의 집합과 이를 연결하는 간선들의 집합으로 구성된 자료 구조
- 유옇
	- 무향 그래프 (Undirected Graph)
	- 유향 그래프 (Directed Graph)
	- 가중치 그래프 (Weighted Graph)
	- 사이클 없는 방향 그래프 (DAG, Directed Acyclic Graph) / 무향은 불가능
	- 완전 그래프 : 정점들에 대해 가능한 모든 간선을 가진 그래프
	- 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
- 인접 정접
	- 인접 (Adjacency) : 두 개의 정점에 간선이 존재하면 인접, 완전 그래프의 모든 정점은 서로 인접
- 경로 :  간선을 순서대로 나열한 것
	- 단순 경로 : 한 정점을 최대 한 번만 지나는 경로
	- 사이클 : 시작한 정점에서 끝나는 경로
- 그래프 표현
	- 간선 정보 저장 방식, 메모리, 성능 등 고려
	- 인접 행렬 (Adjacent matrix)
		- V × V 크기의 2차원 배열을 이용해서 간선 정보 저장
		- 행/열 번호는 정점에 대응
		- 두 정점이 인접이면 1, 아니면 0
		- 무향 그래프 : i번째 행 합 = i번째 열 합 = Vi의 차수
		- 유형 그래프 : 행 i 합 = Vi 진출 차수 / 열 i 합 : Vi 진입 차수
	- 인접 리스트 (Adjacent list)
		- 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
	- 간선의 배열
		- 간선을 배열에 연속적으로 저장

## 2. DFS
- 그래프 순회 : 그래프로 표현된 모든 자료(정점)을 탐색하는 것, DFS / BFS의 두 방법
- DFS
	- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이탐색
	- 더 이상 갈 수 없게 되면, 마지막에 만났던 간선이 있는 정점으로 되돌아가서 탐색
	- 후입선출의 스택 사용
- 연습 : 스택 구현 / 3개 데이터 스택에 넣고 꺼내기
- 알고리즘
    ```python
    # 재귀
	 def DFS_Rec(G, v):
		 visited(v) = True
		 for w in adjancey(G, v):
			 if visited[W] != True:
				 DFS_Rec(G, w)
	 # 반복
	 s = []
	 visited = []
	 def DFS(v):
		 psuh (s, v)
		 while not isEmpty(s):
			 v = pop(s)
			 if not visited[v]:
				 visit(v)
				 for each wa in adjacency(v):
					 if not visited[w]: push(s, w)
    ```
- 연습문제 1 : 모든 정점을 깊이 우선 탐색하여 화면에 깊이 우선 탐색 경로를 출력하시오. 시작 정점은 1이다.
	- 1, 2, 1, 3, 2, 4, 2, 5, 4, 6, 5, 6, 6, 7, 3, 7
	- 출력결과 : 1-2-4-6-5-7-3

## 3. BFS
- 인접 정점을 모두 차례로 방문 후, 방문한 접점을 시작점으로 다시 인접 정점들을 차례로 방문하는 방식
- 큐를 활용
- 연습문제2 : BFS

## 4. 서로소 집합들
- 서로소 집합(Disjoint-sets)
	- 중복 포함된 원소가 없는 집합들
	- 집합에 속한 특정 멤버를 통해 집합을 구분, 이를 대표자(representative)라 함
- 표현 방법 : 연결리스트/트리
- 연산 : Make-Set(x). Find-set(x), Union(x, y)
- 트리로 표현 시 루트 노드가 대표자
	- Union(a, b) : b > a
	- Union(c, b) : b >a > c
	- 문제점 : 깊이가 깊어지면 복잡해짐
- 연산의 효율을 높이는 방법
	- rank 이용
	- Path compression : 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어준다.



## 5. 최소 신장 트리 (MST)
- 최소 비용 문제
	- 모든 정점 연결하는 간선들의 가중치 합이 최소가 되도록
	- 두 정점 사이 최소 비용 경로
- 신장 트리
	- n개 정점 무방향 그래프에서 n개 정점 n-1개 간선 트리
- 최소 신장 트리 (Minimum Spanning Tree)
	- 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리
- Prim 알고리즘
	- 하나의 정점에서 연결된 간선 중 하나씩 선택하며 MST 만들어가는 방식
		1. 임의 정점 하나 선택해 시작
		2. 선택한 정점과 인접하는 정점들 중 최소 비용 간선 존재하는 정점 선택
		3. 1,2 반복
	- 서로소인 2개의 집합 정보 유지
		- 트리 정점들 : MST 만들기 위해 선택된 정점들
		- 비트리 정점들 : 선택되지 않은 정점들
	- 알고리즘
	```python
	def prim(G, r):
		for u in G.V
			u.key = inf
			u.pi = NULL
		r.key = 0
		Q = G.V
		while Q != 0
			u = Extract_min(Q)
			for v in G.Adj[u]
			if v in Q and w(u, v) < v.key:
				v.pi = u
				v.key = w(u,v)
	```
- KRUSKAL 알고리즘
	- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
		1. 최초/모든 간선을 가중치에 따라 오름차순 정렬
		2. 가중치가 가장 낮은 간선부터 선택하면서 트리 증가
			- 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
		3. n-1개 간선 선택될 때까지 반복
	- 알고리즘
	```python
	def kruskal(G,w):
		 A = 0
		 for v in G.V:
			 Make_Set(v)
		 G.E 간선들을 가중치 w에 의해 정렬
		 G.E.sort()
		 for (u,v) in G.E
			 if Find_Set(u) != Find_Set(v):
				 A ← A ∪ {(u,v)}
				 Union(u, v)
		 return A
	```

## 6. 최단 경로
- 간선의 가중치가 있는 그래프에서 두 정점 사이 경로들 중 간선 가중치 합이 최소인 경로
- 시작>끝 : 다익스트라(dijkstra, 음 가중치 x), 벨만-포드(Bellman-Ford, 음 가중치 O)
- 모든 정점 최단경로 : 플로이드-워샬(Floyd-Warshall)
- 다익스트라
	- 시작정점에서 거리가 최소인 정점을 선택해나가면서 최단 경로 구하는 방식
	- 그리디 알고리즘, 프림 알고리즘과 유사
- 알고리즘
	```python
	def dijstra(s,A,D):
	
	```
- 