### 목차
1. 시작하기
2. 기초 문법
3. 함수
4. Array와 Object

## 1. 시작하기

## 2. 기초 문법
1) 코드 작성법
	- 세미콜론 : 선택적 사용 가능, ASI에 의해 자동 삽입
	- 들여쓰기 : 2칸
	- 블럭(block) : 중괄호를 통해 구분(cf. 파이썬은 들여쓰기)
	- 주석 : / / 혹은 /* \*/(여러줄)
2) 변수와 식별자
	- 식별자 : 변수 구별 가능한 변수명
		- 문자, $ 혹은 \_로 시작
		- 대소문자 구분, 클래스명 제외 소문자로 시작
		- 예약어 불가
		- 정의
			- 카멜 케이스(camelcase) : 변수, 객체, 함수에 사용
			- 파스칼 케이스(PascalCase) : 클래스, 생성자
			- 대문자 스네이크 케이스(SNAKE_CASE) : 상수(constants)
		- 변수 선언 키워드
		- | 키워드 | 재선언 | 재할당 | 스코프 | 비고         |
                 | ------ | ------ | ------ | ------ | ------------ |
                 | let    | X      | O      | 블록   | ES6부터 도입 |
                 | const  | X      | X      | 블록   | ES6부터 도입 |
                 | var    | O      | O      | 함수   | 사용 X       |
		- 호이스팅(hoisting) : 선언 이전에 참조가 가능한 현상
		- 블록 스코프 : 블록 스코프 변수는 밖에서 접근 불가
		- 재할당해야 하는 경우만 let 쓰고 나머지는 const 쓰는걸 권장
3) 데이터 타입
	- 원시타입(Primitive type)과 참조 타입(Reference type)으로 구분
	- Number : 정수/실수형 숫자
		- NaN : Not-A-Number, Number.isNaN()으로 파악
			- 반환하는 경우 : 숫자로 읽지 못함, 허수, NaN으로 계산, 정의불가(무한대×0), 문자열 포함하면서 덧셈 아닌 경우
	- String : 문자열, 파이썬과 비슷(따옴표 둘 다, 덧셈)
		- 줄바꿈 안되기 때문에 \\n 사용
		- template literals( \` 사용)하면 줄바꿈 가능, 하지만 escape sequence 사용 불가, `${}`로 중간에 변수도 가능. f-string과 비슷
	- Empty Value : 존재하지 않음, `null`과 `undefined`가 존재
		-  둘에 큰 차이는 없음. 설계상 실수
		- null : 값이 없음을 의도적으로 표현할 때 씀, object로 출력
		- undefined : 값이 정의되어있지 않을 때, undefined로 출력
		- 이미 null에 의존을 많이 하기 때문에 지금까지 유지중
	- Boolean : true, false
		- 자동 형변환
			- | 데이터타입 | false      |
	                 | ---------- | ---------- |
	                 | ---------- | ---------- |
	                 | undefined  | 항상       |
	                 | null       | 항상       |
	                 | Number     | 0, -0, NaN |
	                 | String     | 빈 문자열  |
	                 | Object     | 항상 true  |
4) 연산자
	- 할당 연산자 : 우측 값을 좌측에 할당, +=, -= ++, -- 지원
	- 비교 연산자 : 비교 후 결과를 Boolean으로 반환, 문자는 유니코드순, 대문자>소문자
	- 동등연산자(\=\=) : 같은 값인지, 예상 못 한 결과가 나와 잘 사용 안 함
	- 일치연산자(\=\=\=) : 값과 타입이 모두 같은지
	- 논리연산자 : &&(AND), ||(OR), !(NOT), 단축 평가 지원
	- 삼항연산자 : `조건 ? 참일때 : 거짓일 때`
5) 조건문
	- if statement : if문
		```javascript
		const name = 'manager'
		if (name === 'admin'){
		  console.log('관리자님 환영합니다.')
		} else if (name === 'manager'){
		  console.log('매니저님 환영합니다.')
		} else {
		  console.log(`${name}님 환영합니다.`)
		}
		```
	- switch statment : 결과값이 어느 case에 해당하는지, 조건이 많아지면 if문보다 가독성이 나을 수 있음
		```javascript
		switch(name){
		  case 'admin': {
		    console.log('관리자님 환영합니다.')
		    break // break가 없으면 default도 같이 나옴
		  }
		  case 'manager': {
		    console.log('매니저님 환영합니다.')
		    break
		  }
		  default: {
		    console.log(`${name}님 환영합니다.`)
		  }
		}
		```
1) 반복문
	- while
	```javascript
		while(조건문) {
		  실행
		}
	```
	- for
	```javascript
		for([초기문]; [조건문]; [증감문]) {
		  실행
		}
	```
	- for ... in 
		- 객체 속성 순회할 때, 배열도 가능하지만 인덱스순으로 한다는 보장이 없으므로 비추천
	```javascript
		for (variable in object){
		  statements
		}
	```
	- for ... of
		- 반복 가능한 객체(Array, Set, String)를 순회할 때 사용
		- in은 속성 이름, of는 속성 값을 통해 반복
	```javascript
	for (variable of object) {
	  statements
	}
	```
	- for문 내의 변수는 최초 정의 변수를 재할당하기 때문에 const 아닌 let 사용
	- for in/of는 에러 발생 안 함

## 3. 함수
1) 함수의 정의
	-  일반적
	```javascript
	function 함수명() {
	  실행문
	}
	```
	- 함수 표현식
	 ```javascript
	 const sub = function (num1, num2 = 2) {
	   return num1 - num2
	 }
	 ```
	- 함수의 경우 매개변수/인자 개수 불일치를 허용
	- Spread syntax(...) : 전개 구문
	```javascript
	let parts = ['a', 'b']
	let lyrics = ['c', ...parts, 'd']
	// ['c', 'a', 'b', 'd']
	```
	- 함수에서는 \*arg와 동일
2) 선언식과 표현식
	- 선언식/표현식 모두 타입은 fucntion으로 동일
	```javascript
	// 표현식
	const add = function (args) { }
	
	// 선언식
	function sub(args) { }
	```
	- 선언식의 경우 hoisting이 발생하므로 표현식 권장
3) Arrow Function
	- 함수를 비교적 간결하게 정의할 수 있는 문법
		- function 키워드 생략 가능
		- 매개변수가 하나라면 () 생략 가능
		- 한 줄이면 {}, return 생략 가능
	- \=\= 함수에서만 사용 가능
	```javascript
	const arrow1 = function (name) {
	  return `hello ${name}`
	}
	const arrow2 = (name) => {return `hello, ${name}`}
	const arrow3 = name => {return `hello, ${name}`}
	const arrow4 = name => `hello, ${name}`
	// 인자 없는 경우
	let noArgs = () => 'No Args'
	noArgs = _ => 'No Args'
	//object return 시 return 명시적으로 적어준다.
	let returnObject = () => { return { key: 'value'} }
	returnObject = () => ({ key: 'value' })
	```
	- 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)
		- 선언과 동시에 실행되는 함수
		- 함수 선언 끝에 ()을 넣어 선언하자마자 실행
		- 다시 호출은 불가능
		- 이를 살려 초기화 부분에 많이 사용
		- 익명함수로 사용하는 것이 일반적
	```javascript
	(function(num) {return num ** 3})(2)
	(num => num ** 3)(2)
	```

### 4. Array와 Object
1) 배열(Array)
	- 키와 속성들을 담고 있는 참조 타입의 객체(Object)
	- 순서 보장
	- 인덱싱 가능(마이너스 인덱싱 불가)
	- array.length로 길이
	```javascript
	const n = [1, 2, 3, 4, 5]
	console.log(n[0]) // 1
	console.log(n.length) // 5
	console.log(n[n.length - 2]) // 4
	```
	- 배열 메서드
		- | 메서드          | 설명                                    | 비고         |
	          | --------------- | --------------------------------------- | ------------ |
	          | reverse         | 원본 배열 요소를 반대로                 |              |
	          | push & pop      | 배열 가장 뒤 요소 추가/제거             |              |
	          | unshift & shift | 배열 가장 앞 요소 추가/제거             |              |
	          | includes        | 특정 값 존재하는지 판별 후 참/거짓      |              |
	          | index0f         | 특정 값 존재하는지 판별 후 인덱스 반환  | 없을 경우 -1 |
	          | join            | 배열의 모든 요소를 구분자를 이용해 연결 | 구분자 생략 시 쉼표 |
		```javascript
		const n = [1,2,3]
		n.reverse() // [3, 2, 1]
		n.push(100) // [3, 2, 1, 100]
		n.pop() // [3, 2, 1]
		console.log(n.includes(1)) // true
		console.log(n.index0f(1)) // 2
		n.join('') // 12345
		```
		- | 메서드 | 설명 | 비고 |
		   | ------- | ---------------------------------------------------- | ----------- |
		   | foreach | 각 요소에 대해 콜백 함수 한 번씩 실행                | 반환값 없음 |
		   | map     | 콜백 함수 반환값을 요소로 새로운 배열 반환           |             |
		   | filter  | 콜백 함수 반환값 참인 요소들만 모아 새로운 배열 반환 |             |
		   | reduce  | 반환값들을 하나의 값(acc)에 누적 후 반환             |             |
		   | find    | 반환값이 참이면 해당 요소를 반환                     |             |
		   | some    | 배열의 요소 중 하나라도 통과면 참                    |             |
		   | every   | 배열의 모든 요수가 통과면 참                         |             |
		```javascript
		array.forEach((element, index, array) => {})
		
		const color = ['red', 'blue']
		const nums = [1, 2, 3]
		
		colors.forEach((color) => console.log(color))
		
		const dn = nums.map((num) => num * 2)
		console.log(dn)
		
		const fruits = products.filter((product) => product.type === 'fruit')
		
		const sum = tests.reduce((total, x) => total + x, 0)
		// acc 함수, acc 초기 값
		
		const avenger = avengers.find((avenger) => avenger.name === 'Tony Stark')
		
		const result = nums.some((elem) => elem % 2 === 0) /// true
		const result2 = nums.every((elem) => elem % 2 === 0) // false
		```
2) 객체(objects)
	- 속성(property)의 집합, 중괄호 내부에 key와 value의 쌍으로 표현
		- key : 문자열만 가능, 띄어쓰기 등이 있으면 따옴표로 묶음
		- value : 모든 타입 가능
	- `objects.key` 혹은 `object[key]`로 구현 가능, 따옴표로 묶어야 하는 상황인 경우 대괄호만 가능
	- 관련 ES6 문법
		- 속성명 축약
			- key와 value의 값이 같으면 축약 가능
		- 메서드명 축약
			- 메서드 선언 시 function 키워드 생략 가능
		- 계산된 속성명 사용
			- 계산된 표현식을 이용해 동적 사용 가능
		- 구조 분해 할당
			- object를 이용한 할당에서 중괄호를 이용해 중복 방지
		- 객체 전개 구문(Spread Operator)
			- 배열처럼 전개구문을 통해 객체 전개 가능
			- 얕은 복사에 활용 가능
		```javascript
		const book{
		  books,
		  magazines,
		  greeting() {
		    console.log('Hi!')
		  }
		}
		
		const key = 'country'
		const value = ['한국', '미국']
		
		const obj = {
		  [key]: value
		}
		
		const {books, magazines} = book
		```
	- JavaScriptON
		- Key-Value 형태로 이루어진 자료 표기법
		- Object는 그 자체로 타입, JavaScriptsON은 형식이 있는 String
		- 즉, Object로 사용을 위해선 변환 작업 필요
	- 배열도 index를 키로 가진 객체